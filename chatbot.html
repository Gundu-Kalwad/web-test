<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Pro Coding Studio • Host RPC One-Click Tester</title>
    <style>
      :root { color-scheme: dark; }
      * { box-sizing: border-box; }
      body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: #121418; color: #e6e6e6; }
      header { padding: 12px 16px; background: #1b1f27; border-bottom: 1px solid #2a2f3a; position: sticky; top: 0; z-index: 10; }
      h1 { font-size: 16px; margin: 0; }
      .muted { color: #9aa4b2; font-size: 12px; }
      main { padding: 16px; max-width: 880px; margin: 0 auto; display: grid; gap: 16px; }
      section { border: 1px solid #2a2f3a; border-radius: 10px; background: #0e1116; }
      section > h2 { font-size: 14px; margin: 0; padding: 10px 12px; background: #11151c; border-bottom: 1px solid #2a2f3a; display: flex; align-items: center; justify-content: space-between; gap: 12px; }
      .content { padding: 12px; display: grid; gap: 12px; }
      .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
      button { background: #2a2f3a; color: #fff; border: 1px solid #3a4150; border-radius: 8px; padding: 10px 14px; cursor: pointer; }
      button:hover { background: #333a49; }
      input[type="text"], textarea { background: #0b0e13; color: #fff; border: 1px solid #2a2f3a; border-radius: 8px; padding: 8px 10px; }
      textarea { width: 100%; min-height: 200px; resize: vertical; }
      .log { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background: #0b0e13; border: 1px solid #2a2f3a; border-radius: 10px; padding: 12px; white-space: pre-wrap; }
      .ok { color: #64ffda; }
      .warn { color: #ffd166; }
      .err { color: #ff6b6b; }
    </style>
  </head>
  <body>
    <header>
      <h1>Pro Coding Studio • One-Click Host RPC Test</h1>
      <div class="muted">This page provides a single button to exercise all available host APIs in sequence.</div>
    </header>

    <main>
      <section>
        <h2>
          Controls
          <span class="row">
            <button id="btnRunAll">Run All</button>
            <button id="btnCopyLog" title="Copy log">Copy Log</button>
            <button id="btnClearLog" title="Clear log">Clear</button>
          </span>
        </h2>
        <div class="content">
          <div class="log" id="log"></div>
          <div class="muted">
            Notes:
            <ul>
              <li>Run All will prompt once for a directory (SAF) unless your app has a pre-granted tree URI.</li>
              <li>It creates a temp folder and file, writes text and bytes, opens in editor, sets content, saves, lists, then deletes file and folder.</li>
              <li>Optionally, fill a zip path below to test extraction.</li>
            </ul>
          </div>
          <div class="row">
            <input id="zipPath" type="text" placeholder="Optional zipPath (device local path)" style="min-width: 360px;" />
          </div>
        </div>
      </section>
    </main>

    <script>
      (function(){
        const logEl = document.getElementById('log');
        const runBtn = document.getElementById('btnRunAll');
        const copyBtn = document.getElementById('btnCopyLog');
        const clearBtn = document.getElementById('btnClearLog');
        const zipPathEl = document.getElementById('zipPath');

        const pending = new Map();
        let _id = 1;

        function logLine(text, cls){
          const t = (typeof text === 'string') ? text : safeStringify(text);
          const div = document.createElement('div');
          if (cls) div.className = cls;
          div.textContent = t;
          logEl.appendChild(div);
          logEl.scrollTop = logEl.scrollHeight;
        }
        function safeStringify(v){ try { return JSON.stringify(v, null, 2); } catch { return String(v); } }

        async function copyLog(){
          const text = logEl.innerText;
          try { await navigator.clipboard.writeText(text); logLine('Log copied to clipboard', 'ok'); }
          catch {
            const ta = document.createElement('textarea'); ta.value = text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
            logLine('Log copied (fallback)', 'ok');
          }
        }

        function rpc(method, params={}){
          const id = String(_id++);
          const payload = { id, method, params };
          return new Promise((resolve, reject) => {
            pending.set(id, { resolve, reject, method });
            try{
              if (window.ProCodingHost && typeof window.ProCodingHost.postMessage === 'function') {
                window.ProCodingHost.postMessage(JSON.stringify(payload));
                logLine(`→ ${method} ${safeStringify(params)}`);
              } else {
                reject(new Error('ProCodingHost channel not available'));
              }
            } catch(e){ reject(e); }
          });
        }

        window.addEventListener('message', (ev)=>{
          const data = ev.data;
          if (!data) return;
          if (data.rpc_result || data.rpc_error){
            const bag = data.rpc_result ? data.rpc_result : data.rpc_error;
            const id = bag.id;
            const p = pending.get(id);
            if (!p) return;
            pending.delete(id);
            if (data.rpc_result){
              logLine(`✓ ${p.method} ${safeStringify(bag.result)}`, 'ok');
              p.resolve(bag.result);
            } else {
              logLine(`✗ ${p.method} ${bag.code || ''} ${bag.message || ''}`, 'err');
              p.reject(new Error(bag.message || 'RPC error'));
            }
            return;
          }
          if (data.type){ logLine(`message: ${safeStringify(data)}`); }
        });

        clearBtn.addEventListener('click', ()=>{ logEl.innerHTML = ''; });
        copyBtn.addEventListener('click', copyLog);

        function toB64(s){ try { return btoa(unescape(encodeURIComponent(s))); } catch { return btoa(s); } }

        runBtn.addEventListener('click', async ()=>{
          runBtn.disabled = true;
          logLine('=== Run All started ===');
          const ts = new Date().toISOString().replace(/[:.]/g, '-');
          const demoFolder = `agent_demo_${ts}`;
          const demoFile = `hello_${ts}.txt`;

          let baseDir = '';
          let workDir = '';
          let fileUri = '';

          // 1) Toast and device info
          try { await rpc('host.toast', { message: 'Starting Run All…' }); } catch (e) { logLine(e.message, 'err'); }
          try { await rpc('host.device.info', {}); } catch (e) { logLine(e.message, 'err'); }

          // 2) Pick/create working directory
          try {
            const res = await rpc('host.fs.openDocumentTree', {});
            baseDir = res?.uri || '';
            if (!baseDir) { logLine('Directory not selected. Aborting.', 'err'); runBtn.disabled = false; return; }
          } catch (e) { logLine(e.message, 'err'); runBtn.disabled = false; return; }

          try {
            const res = await rpc('host.fs.createDirectory', { directoryUri: baseDir, folderName: demoFolder });
            workDir = res?.uri || baseDir;
          } catch (e) { logLine(e.message, 'err'); workDir = baseDir; }

          // 3) Create file and write/read text
          try {
            const cf = await rpc('host.fs.createFile', { directoryUri: workDir, fileName: demoFile, mimeType: 'text/plain' });
            fileUri = cf?.uri || '';
          } catch (e) { logLine(e.message, 'err'); }

          try {
            await rpc('host.fs.writeFileText', { uri: fileUri, content: `// created by Run All @ ${ts}\nLine 1\n` });
            const r2 = await rpc('host.fs.readFileText', { uri: fileUri });
            logLine({ readBackLen: r2?.content?.length ?? 0 }, 'ok');
          } catch (e) { logLine(e.message, 'err'); }

          // 4) Bytes roundtrip
          try {
            await rpc('host.fs.writeFileBytes', { uri: fileUri, bytes: toB64(`// bytes written @ ${ts}\n`) });
            const r3 = await rpc('host.fs.readFileBytes', { uri: fileUri });
            logLine({ bytesB64Len: (r3?.bytes || '').length }, 'ok');
          } catch (e) { logLine(e.message, 'err'); }

          // 5) File info
          try { await rpc('host.fs.getFileInfo', { uri: fileUri }); } catch (e) { logLine(e.message, 'err'); }

          // 6) Editor flow: open, set content, save
          try {
            await rpc('host.editor.openDocument', { uri: fileUri });
            const current = await rpc('host.editor.getCurrentContent', {});
            const newContent = `// set by Run All @ ${ts}\n` + (current?.content || '');
            await rpc('host.editor.setContent', { content: newContent });
            await rpc('host.editor.saveActiveDocument', {});
          } catch (e) { logLine(e.message, 'err'); }

          // 7) List files
          try { await rpc('host.fs.listFiles', { directoryUri: workDir }); } catch (e) { logLine(e.message, 'err'); }

          // 8) Optional extract zip
          try {
            const z = zipPathEl.value.trim();
            if (z) await rpc('host.fs.extractZip', { zipPath: z, targetDirectoryUri: workDir });
          } catch (e) { logLine(e.message, 'err'); }

          // 9) Cleanup
          try { if (fileUri) await rpc('host.fs.deleteFile', { uri: fileUri }); } catch (e) { logLine(e.message, 'err'); }
          try { if (workDir) await rpc('host.fs.deleteFile', { uri: workDir }); } catch (e) { logLine('(directory delete may fail if not empty)', 'warn'); }

          // 10) Native bridge sanity
          try { await rpc('android.call', { method: 'device.info', params: {} }); } catch (e) { logLine(e.message, 'err'); }

          try { await rpc('host.toast', { message: 'Run All complete ✅' }); } catch {}
          logLine('=== Run All complete ===', 'ok');
          runBtn.disabled = false;
        });

        // Send a small welcome ping
        setTimeout(() => {
          try { window.ProCodingHost.postMessage(JSON.stringify({ type: 'panel:ping' })); logLine('→ panel:ping (init)'); } catch {}
        }, 200);
      })();
    </script>
  </body>
</html>
